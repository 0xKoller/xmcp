---
title: "xmcp - Documentation"
metadataTitle: "xmcp - Getting Started | Documentation"
publishedAt: "2025-07-06"
summary: "The framework for building & shipping MCP applications."
---

# Documentation

`xmcp` is a framework for building and shipping MCP applications with TypeScript. Designed with DX in mind, it simplifies setup and removes friction in just one command — making it easy to build & deploy AI tools on top of the Model Context Protocol ecosystem.

## Getting started

You can create a new xmcp application from scratch or add it to an existing project:

- [Create a new xmcp application from scratch](#create-a-new-xmcp-app)
- [Add xmcp to your existing Next.js app](#usage-with-nextjs)
- [Add xmcp to your existing Express app](#usage-with-express)
- [Browse examples](https://github.com/basementstudio/xmcp/tree/main/examples)

<br />

---

### Create a new xmcp app

The easiest way to get started with `xmcp` is by using `create-xmcp-app`. This CLI tool allows you to scaffold a template project with all the necessary files and dependencies to get you up and running quickly.

```bash
npx create-xmcp-app@latest
```

You will be asked for the project name and then guided through a series of prompts to configure your project.

#### Building with HTTP

The HTTP transport is your go to choice when you want to deploy your MCP on a server. This can be used to create tools like fetching your database or perform fetch operations.

`xmcp` uses stateless servers. This means that every time you call a tool, a new transport will be instantiated. There is no tracking of sessions or state.

To configure your server for usage in any MCP client, the configuration should be as follows:

```json
{
  "mcpServers": {
    "my-project": {
      "url": "http://localhost:3002/mcp"
    }
  }
}
```

The `url` is the endpoint where the MCP server is running. Port defaults to `3002`.

#### Building with STDIO

The STDIO transport is useful when you want to use your MCP server locally, useful for enabling your AI to perform operations on your machine. For example, you can create tools like searching and compressing images on a folder.
You can also publish the server as a package on NPM.

#### Building with both

You can also build your MCP server with both transports. This is useful when you want to use your MCP server locally and on a server.

```bash
xmcp build --stdio --http
```

## Project structure

A basic project structure is as follows:

```
my-project/
├── src/
│   ├── middleware.ts   # Middleware for http request/response processing
│   └── tools/          # Tool files are auto-discovered here
│       ├── greet.ts
│       ├── search.ts
├── dist/               # Built output (generated)
├── package.json
├── tsconfig.json
└── xmcp.config.ts       # Configuration file for xmcp
```

### Creating tools

`xmcp` detects files under `tools` directory that you have set on installation and registers them as tools. This path can be configured in the `xmcp.config.ts` file.

The tool file should export three elements:

- **Schema**: The input parameters using Zod schemas.
- **Metadata**: The tool's identity and behavior hints.
- **Default**: The tool handler function.

```typescript
// src/tools/greet.ts

import { z } from "zod";
import { type InferSchema } from "xmcp";

// Define the schema for tool parameters
export const schema = {
  name: z.string().describe("The name of the user to greet"),
};

// Define tool metadata
export const metadata = {
  name: "greet",
  description: "Greet the user",
  annotations: {
    title: "Greet the user",
    readOnlyHint: true,
    destructiveHint: false,
    idempotentHint: true,
  },
};

// Tool implementation
export default async function greet({ name }: InferSchema<typeof schema>) {
  const result = `Hello, ${name}!`;

  return {
    content: [{ type: "text", text: result }],
  };
}
```

### File exports

#### 1. Schema

The schema object defines the tool's parameters with:

- **Key**: Parameter name.
- **Value**: Zod schema with `.describe()` for documentation. This will be visibile through the inspector.
- **Purpose**: Type validation and automatic parameter documentation.

#### 2. Metadata

Define the tool's identity and behavior hints. The metadata object provides:

- **Name**: Unique identifier for the tool
- **Description**: Brief explanation of what the tool does
- **Annotations**: Behavioral hints for AI models and UIs

#### 3. Implementation

The default export function that performs the actual work.

- **Parameters**: Automatically typed from your schema using the built-in `InferSchema`.
- **Returns**: MCP-compatible response with content array.
- **Async**: Supports async operations for API calls, file I/O, etc.

## Development Commands

```bash
# Start development server with hot reloading
npm run dev

# Build for production
npm run build

# Start built server (STDIO transport)
node dist/stdio.js

# Start built server (HTTP transport)
node dist/http.js
```

## Using tools

At this point, you can configure your MCP server on clients like Cursor.

If you're using the HTTP transport, your configuration should look like this:

```json
{
  "mcpServers": {
    "my-project": {
      "url": "http://localhost:3002/mcp"
    }
  }
}
```

If you're using the STDIO transport, your configuration for local development should look like this:

```json
{
  "mcpServers": {
    "my-project": {
      "command": "node",
      "args": ["/ABSOLUTE/PATH/TO/PARENT/FOLDER/my-project/dist/stdio.js"]
    }
  }
}
```

## Middlewares

When building an `HTTP server`, you can use middlewares to intercept the request and response. This is useful for authentication, rate limiting, and other common tasks.

To get started, create a `middleware.ts` file with the following content:

```typescript
// src/middleware.ts

import { type Middleware } from "xmcp";

const middleware: Middleware = async (req, res, next) => {
  const authHeader = req.headers.authorization;

  if (!customHeaderValidation(authHeader)) {
    res.status(401).json({ error: "Invalid API key" });
    return;
  }

  return next();
};

export default middleware;
```

Middlewares can also be an array of middlewares. Useful for when you need to chain multiple middlewares.

```typescript
// src/middleware.ts

import { type Middleware } from "xmcp";

const middleware: Middleware = [
  (req, res, next) => {
    // ...
    return next();
  },
  // ... other middlewares
];

export default middleware;
```

## Authentication

### API Key Authentication

To enable API key authentication, you can use the `apiKeyAuthMiddleware` middleware on your app.

```typescript
// src/middleware.ts

import { apiKeyAuthMiddleware, type Middleware } from "xmcp";

const middleware: Middleware = [
  apiKeyAuthMiddleware({
    headerName: "x-api-key",
    apiKey: "12345",
  }),
  // ... other middlewares
];

export default middleware;
```

This middleware can also be used with a validation function. It should **return a boolean** value indicating if the API key is valid.

```typescript
// src/middleware.ts

import { apiKeyAuthMiddleware, type Middleware } from "xmcp";

const middleware: Middleware = apiKeyAuthMiddleware({
  headerName: "x-api-key",
  validateApiKey: async (apiKey) => {
    return apiKey === "12345";
  },
});

export default middleware;
```

## xmcp/headers

If you are building an HTTP server, you can access the request headers using the `xmcp/headers` module.

For example, you can use the `x-api-key` header to fetch data from an external API.

```typescript
// src/tools/search.ts

import { headers } from "xmcp/headers";

// ... schema and metadata

export default async function search({ query }: InferSchema<typeof schema>) {
  const headers = headers();
  const apiKey = headers["x-api-key"];

  const data = await fetchSomeData(apiKey);

  return {
    content: [{ type: "text", text: JSON.stringify(data) }],
  };
}
```

## Vercel Deployment

xmcp can be deployed to Vercel with the `--vercel` flag. This will create `.vercel` directory with the built output.

```bash
xmcp build --vercel

vercel deploy --prod --prebuilt
```

## Usage with Next.js

> **Warning**: This is an experimental feature and may not work as expected.

`xmcp` can work on top of your existing Next.js project. To get started, run the following command:

```bash
npx init-xmcp@latest
```

After setting up the project, your build and dev command should look like this:

```json
{
  "scripts": {
    "dev": "xmcp dev & next dev",
    "build": "xmcp build && next build"
  }
}
```

The CLI will ask where to place the `tools` directory and what is the `url` for the MCP server.

It will create the tools folder and add an endpoint to your Next.js app.

```typescript
// src/app/mcp/route.ts

import { xmcpHandler } from "@xmcp/adapter";

export { xmcpHandler as GET, xmcpHandler as POST };
```

Note: `middleware.ts` and `xmcp/headers` are not supported since Next.js already supports those features.

## Usage with Express

> **Warning**: This is an experimental feature and may not work as expected.

`xmcp` can work on top of your existing Express project. To get started, run the following command:

```bash
npx init-xmcp@latest
```

After setting up the project, your build and dev command should look like this:

```json
{
  "scripts": {
    "dev": "xmcp dev & existing-build-command",
    "build": "xmcp build && existing-build-command"
  }
}
```

When running `dev` or `build` command, `xmcp` will bundle your tools into `.xmcp/adapter`.

You should add the `/mcp` endpoint in your existing server.

```typescript
import { xmcpHandler } from "path/to/.xmcp/adapter";

app.get("/mcp", xmcpHandler);

app.post("/mcp", xmcpHandler);
```

Note: `middleware.ts` is not supported in this mode.
